// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation

internal func == (lhs: TimestampAndAudioTime, rhs: TimestampAndAudioTime) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTime == rhs.hasTime) && (!lhs.hasTime || lhs.time == rhs.time)
  fieldCheck = fieldCheck && (lhs.hasAudioTime == rhs.hasAudioTime) && (!lhs.hasAudioTime || lhs.audioTime == rhs.audioTime)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

internal func == (lhs: Location, rhs: Location) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = fieldCheck && (lhs.hasAltitude == rhs.hasAltitude) && (!lhs.hasAltitude || lhs.altitude == rhs.altitude)
  fieldCheck = fieldCheck && (lhs.hasFloor == rhs.hasFloor) && (!lhs.hasFloor || lhs.floor == rhs.floor)
  fieldCheck = fieldCheck && (lhs.hasHorizontalAccuracy == rhs.hasHorizontalAccuracy) && (!lhs.hasHorizontalAccuracy || lhs.horizontalAccuracy == rhs.horizontalAccuracy)
  fieldCheck = fieldCheck && (lhs.hasVerticalAccuracy == rhs.hasVerticalAccuracy) && (!lhs.hasVerticalAccuracy || lhs.verticalAccuracy == rhs.verticalAccuracy)
  fieldCheck = fieldCheck && (lhs.hasSpeed == rhs.hasSpeed) && (!lhs.hasSpeed || lhs.speed == rhs.speed)
  fieldCheck = fieldCheck && (lhs.hasCourse == rhs.hasCourse) && (!lhs.hasCourse || lhs.course == rhs.course)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

internal func == (lhs: Heading, rhs: Heading) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = fieldCheck && (lhs.hasMagneticHeading == rhs.hasMagneticHeading) && (!lhs.hasMagneticHeading || lhs.magneticHeading == rhs.magneticHeading)
  fieldCheck = fieldCheck && (lhs.hasHeadingAccuracy == rhs.hasHeadingAccuracy) && (!lhs.hasHeadingAccuracy || lhs.headingAccuracy == rhs.headingAccuracy)
  fieldCheck = fieldCheck && (lhs.hasX == rhs.hasX) && (!lhs.hasX || lhs.x == rhs.x)
  fieldCheck = fieldCheck && (lhs.hasY == rhs.hasY) && (!lhs.hasY || lhs.y == rhs.y)
  fieldCheck = fieldCheck && (lhs.hasZ == rhs.hasZ) && (!lhs.hasZ || lhs.z == rhs.z)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

internal struct LocationRoot {
  internal static var sharedInstance : LocationRoot {
   struct Static {
       static let instance : LocationRoot = LocationRoot()
   }
   return Static.instance
  }
  internal var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
    Google.Protobuf.SwiftDescriptorRoot.sharedInstance.registerAllExtensions(extensionRegistry)
  }
  internal func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

final internal class TimestampAndAudioTime : GeneratedMessage, GeneratedMessageProtocol, Hashable {
  private(set) var hasTime:Bool = false
  private(set) var time:Double = Double(0)

  private(set) var hasAudioTime:Bool = false
  private(set) var audioTime:Double = Double(0)

  required internal init() {
       super.init()
  }
  override internal func isInitialized() -> Bool {
   return true
  }
  override internal func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasTime {
      output.writeDouble(1, value:time)
    }
    if hasAudioTime {
      output.writeDouble(2, value:audioTime)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override internal func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasTime {
      serialize_size += time.computeDoubleSize(1)
    }
    if hasAudioTime {
      serialize_size += audioTime.computeDoubleSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  internal class func parseFromData(data:NSData) -> TimestampAndAudioTime {
    return TimestampAndAudioTime.builder().mergeFromData(data, extensionRegistry:LocationRoot.sharedInstance.extensionRegistry).build()
  }
  internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> TimestampAndAudioTime {
    return TimestampAndAudioTime.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromInputStream(input:NSInputStream) -> TimestampAndAudioTime {
    return TimestampAndAudioTime.builder().mergeFromInputStream(input).build()
  }
  internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TimestampAndAudioTime {
    return TimestampAndAudioTime.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream) -> TimestampAndAudioTime {
    return TimestampAndAudioTime.builder().mergeFromCodedInputStream(input).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TimestampAndAudioTime {
    return TimestampAndAudioTime.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func builder() -> TimestampAndAudioTimeBuilder {
    return TimestampAndAudioTime.classBuilder() as! TimestampAndAudioTimeBuilder
  }
  internal func builder() -> TimestampAndAudioTimeBuilder {
    return classBuilder() as! TimestampAndAudioTimeBuilder
  }
  internal override class func classBuilder() -> MessageBuilder {
    return TimestampAndAudioTimeBuilder()
  }
  internal override func classBuilder() -> MessageBuilder {
    return TimestampAndAudioTime.builder()
  }
  internal func toBuilder() -> TimestampAndAudioTimeBuilder {
    return TimestampAndAudioTime.builderWithPrototype(self)
  }
  internal class func builderWithPrototype(prototype:TimestampAndAudioTime) -> TimestampAndAudioTimeBuilder {
    return TimestampAndAudioTime.builder().mergeFrom(prototype)
  }
  override internal func writeDescriptionTo(inout output:String, indent:String) {
    if hasTime {
      output += "\(indent) time: \(time) \n"
    }
    if hasAudioTime {
      output += "\(indent) audioTime: \(audioTime) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override internal var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTime {
             hashCode = (hashCode &* 31) &+ time.hashValue
          }
          if hasAudioTime {
             hashCode = (hashCode &* 31) &+ audioTime.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override internal class func className() -> String {
      return "TimestampAndAudioTime"
  }
  override internal func className() -> String {
      return "TimestampAndAudioTime"
  }
  override internal func classMetaType() -> GeneratedMessage.Type {
      return TimestampAndAudioTime.self
  }
  //Meta information declaration end

}

final internal class TimestampAndAudioTimeBuilder : GeneratedMessageBuilder {
  private var builderResult:TimestampAndAudioTime

  required override internal init () {
     builderResult = TimestampAndAudioTime()
     super.init()
  }
  var hasTime:Bool {
       get {
            return builderResult.hasTime
       }
  }
  var time:Double {
       get {
            return builderResult.time
       }
       set (value) {
           builderResult.hasTime = true
           builderResult.time = value
       }
  }
  func setTime(value:Double)-> TimestampAndAudioTimeBuilder {
    self.time = value
    return self
  }
  internal func clearTime() -> TimestampAndAudioTimeBuilder{
       builderResult.hasTime = false
       builderResult.time = Double(0)
       return self
  }
  var hasAudioTime:Bool {
       get {
            return builderResult.hasAudioTime
       }
  }
  var audioTime:Double {
       get {
            return builderResult.audioTime
       }
       set (value) {
           builderResult.hasAudioTime = true
           builderResult.audioTime = value
       }
  }
  func setAudioTime(value:Double)-> TimestampAndAudioTimeBuilder {
    self.audioTime = value
    return self
  }
  internal func clearAudioTime() -> TimestampAndAudioTimeBuilder{
       builderResult.hasAudioTime = false
       builderResult.audioTime = Double(0)
       return self
  }
  override internal var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  internal override func clear() -> TimestampAndAudioTimeBuilder {
    builderResult = TimestampAndAudioTime()
    return self
  }
  internal override func clone() -> TimestampAndAudioTimeBuilder {
    return TimestampAndAudioTime.builderWithPrototype(builderResult)
  }
  internal override func build() -> TimestampAndAudioTime {
       checkInitialized()
       return buildPartial()
  }
  internal func buildPartial() -> TimestampAndAudioTime {
    var returnMe:TimestampAndAudioTime = builderResult
    return returnMe
  }
  internal func mergeFrom(other:TimestampAndAudioTime) -> TimestampAndAudioTimeBuilder {
    if (other == TimestampAndAudioTime()) {
     return self
    }
    if other.hasTime {
         time = other.time
    }
    if other.hasAudioTime {
         audioTime = other.audioTime
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream) ->TimestampAndAudioTimeBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TimestampAndAudioTimeBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 9 :
        time = input.readDouble()

      case 17 :
        audioTime = input.readDouble()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final internal class Location : GeneratedMessage, GeneratedMessageProtocol, Hashable {
  private(set) var hasTimestamp:Bool = false
  private(set) var timestamp:TimestampAndAudioTime!
  private(set) var hasLatitude:Bool = false
  private(set) var latitude:Double = Double(0)

  private(set) var hasLongitude:Bool = false
  private(set) var longitude:Double = Double(0)

  private(set) var hasAltitude:Bool = false
  private(set) var altitude:Double = Double(0)

  private(set) var hasFloor:Bool = false
  private(set) var floor:Int32 = Int32(0)

  private(set) var hasHorizontalAccuracy:Bool = false
  private(set) var horizontalAccuracy:Double = Double(0)

  private(set) var hasVerticalAccuracy:Bool = false
  private(set) var verticalAccuracy:Double = Double(0)

  private(set) var hasSpeed:Bool = false
  private(set) var speed:Double = Double(0)

  private(set) var hasCourse:Bool = false
  private(set) var course:Double = Double(0)

  required internal init() {
       super.init()
  }
  override internal func isInitialized() -> Bool {
   return true
  }
  override internal func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasTimestamp {
      output.writeMessage(1, value:timestamp)
    }
    if hasLatitude {
      output.writeDouble(2, value:latitude)
    }
    if hasLongitude {
      output.writeDouble(3, value:longitude)
    }
    if hasAltitude {
      output.writeDouble(4, value:altitude)
    }
    if hasFloor {
      output.writeInt32(5, value:floor)
    }
    if hasHorizontalAccuracy {
      output.writeDouble(6, value:horizontalAccuracy)
    }
    if hasVerticalAccuracy {
      output.writeDouble(7, value:verticalAccuracy)
    }
    if hasSpeed {
      output.writeDouble(8, value:speed)
    }
    if hasCourse {
      output.writeDouble(9, value:course)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override internal func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasTimestamp {
        if let varSizetimestamp = timestamp?.computeMessageSize(1) {
            serialize_size += varSizetimestamp
        }
    }
    if hasLatitude {
      serialize_size += latitude.computeDoubleSize(2)
    }
    if hasLongitude {
      serialize_size += longitude.computeDoubleSize(3)
    }
    if hasAltitude {
      serialize_size += altitude.computeDoubleSize(4)
    }
    if hasFloor {
      serialize_size += floor.computeInt32Size(5)
    }
    if hasHorizontalAccuracy {
      serialize_size += horizontalAccuracy.computeDoubleSize(6)
    }
    if hasVerticalAccuracy {
      serialize_size += verticalAccuracy.computeDoubleSize(7)
    }
    if hasSpeed {
      serialize_size += speed.computeDoubleSize(8)
    }
    if hasCourse {
      serialize_size += course.computeDoubleSize(9)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  internal class func parseFromData(data:NSData) -> Location {
    return Location.builder().mergeFromData(data, extensionRegistry:LocationRoot.sharedInstance.extensionRegistry).build()
  }
  internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Location {
    return Location.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromInputStream(input:NSInputStream) -> Location {
    return Location.builder().mergeFromInputStream(input).build()
  }
  internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Location {
    return Location.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream) -> Location {
    return Location.builder().mergeFromCodedInputStream(input).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Location {
    return Location.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func builder() -> LocationBuilder {
    return Location.classBuilder() as! LocationBuilder
  }
  internal func builder() -> LocationBuilder {
    return classBuilder() as! LocationBuilder
  }
  internal override class func classBuilder() -> MessageBuilder {
    return LocationBuilder()
  }
  internal override func classBuilder() -> MessageBuilder {
    return Location.builder()
  }
  internal func toBuilder() -> LocationBuilder {
    return Location.builderWithPrototype(self)
  }
  internal class func builderWithPrototype(prototype:Location) -> LocationBuilder {
    return Location.builder().mergeFrom(prototype)
  }
  override internal func writeDescriptionTo(inout output:String, indent:String) {
    if hasTimestamp {
      output += "\(indent) timestamp {\n"
      timestamp?.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasLatitude {
      output += "\(indent) latitude: \(latitude) \n"
    }
    if hasLongitude {
      output += "\(indent) longitude: \(longitude) \n"
    }
    if hasAltitude {
      output += "\(indent) altitude: \(altitude) \n"
    }
    if hasFloor {
      output += "\(indent) floor: \(floor) \n"
    }
    if hasHorizontalAccuracy {
      output += "\(indent) horizontalAccuracy: \(horizontalAccuracy) \n"
    }
    if hasVerticalAccuracy {
      output += "\(indent) verticalAccuracy: \(verticalAccuracy) \n"
    }
    if hasSpeed {
      output += "\(indent) speed: \(speed) \n"
    }
    if hasCourse {
      output += "\(indent) course: \(course) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override internal var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTimestamp {
              if let hashValuetimestamp = timestamp?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuetimestamp
              }
          }
          if hasLatitude {
             hashCode = (hashCode &* 31) &+ latitude.hashValue
          }
          if hasLongitude {
             hashCode = (hashCode &* 31) &+ longitude.hashValue
          }
          if hasAltitude {
             hashCode = (hashCode &* 31) &+ altitude.hashValue
          }
          if hasFloor {
             hashCode = (hashCode &* 31) &+ floor.hashValue
          }
          if hasHorizontalAccuracy {
             hashCode = (hashCode &* 31) &+ horizontalAccuracy.hashValue
          }
          if hasVerticalAccuracy {
             hashCode = (hashCode &* 31) &+ verticalAccuracy.hashValue
          }
          if hasSpeed {
             hashCode = (hashCode &* 31) &+ speed.hashValue
          }
          if hasCourse {
             hashCode = (hashCode &* 31) &+ course.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override internal class func className() -> String {
      return "Location"
  }
  override internal func className() -> String {
      return "Location"
  }
  override internal func classMetaType() -> GeneratedMessage.Type {
      return Location.self
  }
  //Meta information declaration end

}

final internal class LocationBuilder : GeneratedMessageBuilder {
  private var builderResult:Location

  required override internal init () {
     builderResult = Location()
     super.init()
  }
  var hasTimestamp:Bool {
       get {
           return builderResult.hasTimestamp
       }
  }
  var timestamp:TimestampAndAudioTime! {
       get {
           return builderResult.timestamp
       }
       set (value) {
           builderResult.hasTimestamp = true
           builderResult.timestamp = value
       }
  }
  func setTimestamp(value:TimestampAndAudioTime!)-> LocationBuilder {
    self.timestamp = value
    return self
  }
  internal func mergeTimestamp(value:TimestampAndAudioTime) -> LocationBuilder {
    if (builderResult.hasTimestamp) {
      builderResult.timestamp = TimestampAndAudioTime.builderWithPrototype(builderResult.timestamp).mergeFrom(value).buildPartial()
    } else {
      builderResult.timestamp = value
    }
    builderResult.hasTimestamp = true
    return self
  }
  internal func clearTimestamp() -> LocationBuilder {
    builderResult.hasTimestamp = false
    builderResult.timestamp = nil
    return self
  }
  var hasLatitude:Bool {
       get {
            return builderResult.hasLatitude
       }
  }
  var latitude:Double {
       get {
            return builderResult.latitude
       }
       set (value) {
           builderResult.hasLatitude = true
           builderResult.latitude = value
       }
  }
  func setLatitude(value:Double)-> LocationBuilder {
    self.latitude = value
    return self
  }
  internal func clearLatitude() -> LocationBuilder{
       builderResult.hasLatitude = false
       builderResult.latitude = Double(0)
       return self
  }
  var hasLongitude:Bool {
       get {
            return builderResult.hasLongitude
       }
  }
  var longitude:Double {
       get {
            return builderResult.longitude
       }
       set (value) {
           builderResult.hasLongitude = true
           builderResult.longitude = value
       }
  }
  func setLongitude(value:Double)-> LocationBuilder {
    self.longitude = value
    return self
  }
  internal func clearLongitude() -> LocationBuilder{
       builderResult.hasLongitude = false
       builderResult.longitude = Double(0)
       return self
  }
  var hasAltitude:Bool {
       get {
            return builderResult.hasAltitude
       }
  }
  var altitude:Double {
       get {
            return builderResult.altitude
       }
       set (value) {
           builderResult.hasAltitude = true
           builderResult.altitude = value
       }
  }
  func setAltitude(value:Double)-> LocationBuilder {
    self.altitude = value
    return self
  }
  internal func clearAltitude() -> LocationBuilder{
       builderResult.hasAltitude = false
       builderResult.altitude = Double(0)
       return self
  }
  var hasFloor:Bool {
       get {
            return builderResult.hasFloor
       }
  }
  var floor:Int32 {
       get {
            return builderResult.floor
       }
       set (value) {
           builderResult.hasFloor = true
           builderResult.floor = value
       }
  }
  func setFloor(value:Int32)-> LocationBuilder {
    self.floor = value
    return self
  }
  internal func clearFloor() -> LocationBuilder{
       builderResult.hasFloor = false
       builderResult.floor = Int32(0)
       return self
  }
  var hasHorizontalAccuracy:Bool {
       get {
            return builderResult.hasHorizontalAccuracy
       }
  }
  var horizontalAccuracy:Double {
       get {
            return builderResult.horizontalAccuracy
       }
       set (value) {
           builderResult.hasHorizontalAccuracy = true
           builderResult.horizontalAccuracy = value
       }
  }
  func setHorizontalAccuracy(value:Double)-> LocationBuilder {
    self.horizontalAccuracy = value
    return self
  }
  internal func clearHorizontalAccuracy() -> LocationBuilder{
       builderResult.hasHorizontalAccuracy = false
       builderResult.horizontalAccuracy = Double(0)
       return self
  }
  var hasVerticalAccuracy:Bool {
       get {
            return builderResult.hasVerticalAccuracy
       }
  }
  var verticalAccuracy:Double {
       get {
            return builderResult.verticalAccuracy
       }
       set (value) {
           builderResult.hasVerticalAccuracy = true
           builderResult.verticalAccuracy = value
       }
  }
  func setVerticalAccuracy(value:Double)-> LocationBuilder {
    self.verticalAccuracy = value
    return self
  }
  internal func clearVerticalAccuracy() -> LocationBuilder{
       builderResult.hasVerticalAccuracy = false
       builderResult.verticalAccuracy = Double(0)
       return self
  }
  var hasSpeed:Bool {
       get {
            return builderResult.hasSpeed
       }
  }
  var speed:Double {
       get {
            return builderResult.speed
       }
       set (value) {
           builderResult.hasSpeed = true
           builderResult.speed = value
       }
  }
  func setSpeed(value:Double)-> LocationBuilder {
    self.speed = value
    return self
  }
  internal func clearSpeed() -> LocationBuilder{
       builderResult.hasSpeed = false
       builderResult.speed = Double(0)
       return self
  }
  var hasCourse:Bool {
       get {
            return builderResult.hasCourse
       }
  }
  var course:Double {
       get {
            return builderResult.course
       }
       set (value) {
           builderResult.hasCourse = true
           builderResult.course = value
       }
  }
  func setCourse(value:Double)-> LocationBuilder {
    self.course = value
    return self
  }
  internal func clearCourse() -> LocationBuilder{
       builderResult.hasCourse = false
       builderResult.course = Double(0)
       return self
  }
  override internal var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  internal override func clear() -> LocationBuilder {
    builderResult = Location()
    return self
  }
  internal override func clone() -> LocationBuilder {
    return Location.builderWithPrototype(builderResult)
  }
  internal override func build() -> Location {
       checkInitialized()
       return buildPartial()
  }
  internal func buildPartial() -> Location {
    var returnMe:Location = builderResult
    return returnMe
  }
  internal func mergeFrom(other:Location) -> LocationBuilder {
    if (other == Location()) {
     return self
    }
    if (other.hasTimestamp) {
        mergeTimestamp(other.timestamp)
    }
    if other.hasLatitude {
         latitude = other.latitude
    }
    if other.hasLongitude {
         longitude = other.longitude
    }
    if other.hasAltitude {
         altitude = other.altitude
    }
    if other.hasFloor {
         floor = other.floor
    }
    if other.hasHorizontalAccuracy {
         horizontalAccuracy = other.horizontalAccuracy
    }
    if other.hasVerticalAccuracy {
         verticalAccuracy = other.verticalAccuracy
    }
    if other.hasSpeed {
         speed = other.speed
    }
    if other.hasCourse {
         course = other.course
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream) ->LocationBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> LocationBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:TimestampAndAudioTimeBuilder = TimestampAndAudioTime.builder()
        if hasTimestamp {
          subBuilder.mergeFrom(timestamp)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        timestamp = subBuilder.buildPartial()

      case 17 :
        latitude = input.readDouble()

      case 25 :
        longitude = input.readDouble()

      case 33 :
        altitude = input.readDouble()

      case 40 :
        floor = input.readInt32()

      case 49 :
        horizontalAccuracy = input.readDouble()

      case 57 :
        verticalAccuracy = input.readDouble()

      case 65 :
        speed = input.readDouble()

      case 73 :
        course = input.readDouble()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final internal class Heading : GeneratedMessage, GeneratedMessageProtocol, Hashable {
  private(set) var hasTimestamp:Bool = false
  private(set) var timestamp:TimestampAndAudioTime!
  private(set) var hasMagneticHeading:Bool = false
  private(set) var magneticHeading:Double = Double(0)

  private(set) var hasHeadingAccuracy:Bool = false
  private(set) var headingAccuracy:Double = Double(0)

  private(set) var hasX:Bool = false
  private(set) var x:Double = Double(0)

  private(set) var hasY:Bool = false
  private(set) var y:Double = Double(0)

  private(set) var hasZ:Bool = false
  private(set) var z:Double = Double(0)

  required internal init() {
       super.init()
  }
  override internal func isInitialized() -> Bool {
   return true
  }
  override internal func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasTimestamp {
      output.writeMessage(1, value:timestamp)
    }
    if hasMagneticHeading {
      output.writeDouble(2, value:magneticHeading)
    }
    if hasHeadingAccuracy {
      output.writeDouble(3, value:headingAccuracy)
    }
    if hasX {
      output.writeDouble(4, value:x)
    }
    if hasY {
      output.writeDouble(5, value:y)
    }
    if hasZ {
      output.writeDouble(6, value:z)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override internal func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasTimestamp {
        if let varSizetimestamp = timestamp?.computeMessageSize(1) {
            serialize_size += varSizetimestamp
        }
    }
    if hasMagneticHeading {
      serialize_size += magneticHeading.computeDoubleSize(2)
    }
    if hasHeadingAccuracy {
      serialize_size += headingAccuracy.computeDoubleSize(3)
    }
    if hasX {
      serialize_size += x.computeDoubleSize(4)
    }
    if hasY {
      serialize_size += y.computeDoubleSize(5)
    }
    if hasZ {
      serialize_size += z.computeDoubleSize(6)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  internal class func parseFromData(data:NSData) -> Heading {
    return Heading.builder().mergeFromData(data, extensionRegistry:LocationRoot.sharedInstance.extensionRegistry).build()
  }
  internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Heading {
    return Heading.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromInputStream(input:NSInputStream) -> Heading {
    return Heading.builder().mergeFromInputStream(input).build()
  }
  internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Heading {
    return Heading.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream) -> Heading {
    return Heading.builder().mergeFromCodedInputStream(input).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Heading {
    return Heading.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func builder() -> HeadingBuilder {
    return Heading.classBuilder() as! HeadingBuilder
  }
  internal func builder() -> HeadingBuilder {
    return classBuilder() as! HeadingBuilder
  }
  internal override class func classBuilder() -> MessageBuilder {
    return HeadingBuilder()
  }
  internal override func classBuilder() -> MessageBuilder {
    return Heading.builder()
  }
  internal func toBuilder() -> HeadingBuilder {
    return Heading.builderWithPrototype(self)
  }
  internal class func builderWithPrototype(prototype:Heading) -> HeadingBuilder {
    return Heading.builder().mergeFrom(prototype)
  }
  override internal func writeDescriptionTo(inout output:String, indent:String) {
    if hasTimestamp {
      output += "\(indent) timestamp {\n"
      timestamp?.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasMagneticHeading {
      output += "\(indent) magneticHeading: \(magneticHeading) \n"
    }
    if hasHeadingAccuracy {
      output += "\(indent) headingAccuracy: \(headingAccuracy) \n"
    }
    if hasX {
      output += "\(indent) x: \(x) \n"
    }
    if hasY {
      output += "\(indent) y: \(y) \n"
    }
    if hasZ {
      output += "\(indent) z: \(z) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override internal var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTimestamp {
              if let hashValuetimestamp = timestamp?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuetimestamp
              }
          }
          if hasMagneticHeading {
             hashCode = (hashCode &* 31) &+ magneticHeading.hashValue
          }
          if hasHeadingAccuracy {
             hashCode = (hashCode &* 31) &+ headingAccuracy.hashValue
          }
          if hasX {
             hashCode = (hashCode &* 31) &+ x.hashValue
          }
          if hasY {
             hashCode = (hashCode &* 31) &+ y.hashValue
          }
          if hasZ {
             hashCode = (hashCode &* 31) &+ z.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override internal class func className() -> String {
      return "Heading"
  }
  override internal func className() -> String {
      return "Heading"
  }
  override internal func classMetaType() -> GeneratedMessage.Type {
      return Heading.self
  }
  //Meta information declaration end

}

final internal class HeadingBuilder : GeneratedMessageBuilder {
  private var builderResult:Heading

  required override internal init () {
     builderResult = Heading()
     super.init()
  }
  var hasTimestamp:Bool {
       get {
           return builderResult.hasTimestamp
       }
  }
  var timestamp:TimestampAndAudioTime! {
       get {
           return builderResult.timestamp
       }
       set (value) {
           builderResult.hasTimestamp = true
           builderResult.timestamp = value
       }
  }
  func setTimestamp(value:TimestampAndAudioTime!)-> HeadingBuilder {
    self.timestamp = value
    return self
  }
  internal func mergeTimestamp(value:TimestampAndAudioTime) -> HeadingBuilder {
    if (builderResult.hasTimestamp) {
      builderResult.timestamp = TimestampAndAudioTime.builderWithPrototype(builderResult.timestamp).mergeFrom(value).buildPartial()
    } else {
      builderResult.timestamp = value
    }
    builderResult.hasTimestamp = true
    return self
  }
  internal func clearTimestamp() -> HeadingBuilder {
    builderResult.hasTimestamp = false
    builderResult.timestamp = nil
    return self
  }
  var hasMagneticHeading:Bool {
       get {
            return builderResult.hasMagneticHeading
       }
  }
  var magneticHeading:Double {
       get {
            return builderResult.magneticHeading
       }
       set (value) {
           builderResult.hasMagneticHeading = true
           builderResult.magneticHeading = value
       }
  }
  func setMagneticHeading(value:Double)-> HeadingBuilder {
    self.magneticHeading = value
    return self
  }
  internal func clearMagneticHeading() -> HeadingBuilder{
       builderResult.hasMagneticHeading = false
       builderResult.magneticHeading = Double(0)
       return self
  }
  var hasHeadingAccuracy:Bool {
       get {
            return builderResult.hasHeadingAccuracy
       }
  }
  var headingAccuracy:Double {
       get {
            return builderResult.headingAccuracy
       }
       set (value) {
           builderResult.hasHeadingAccuracy = true
           builderResult.headingAccuracy = value
       }
  }
  func setHeadingAccuracy(value:Double)-> HeadingBuilder {
    self.headingAccuracy = value
    return self
  }
  internal func clearHeadingAccuracy() -> HeadingBuilder{
       builderResult.hasHeadingAccuracy = false
       builderResult.headingAccuracy = Double(0)
       return self
  }
  var hasX:Bool {
       get {
            return builderResult.hasX
       }
  }
  var x:Double {
       get {
            return builderResult.x
       }
       set (value) {
           builderResult.hasX = true
           builderResult.x = value
       }
  }
  func setX(value:Double)-> HeadingBuilder {
    self.x = value
    return self
  }
  internal func clearX() -> HeadingBuilder{
       builderResult.hasX = false
       builderResult.x = Double(0)
       return self
  }
  var hasY:Bool {
       get {
            return builderResult.hasY
       }
  }
  var y:Double {
       get {
            return builderResult.y
       }
       set (value) {
           builderResult.hasY = true
           builderResult.y = value
       }
  }
  func setY(value:Double)-> HeadingBuilder {
    self.y = value
    return self
  }
  internal func clearY() -> HeadingBuilder{
       builderResult.hasY = false
       builderResult.y = Double(0)
       return self
  }
  var hasZ:Bool {
       get {
            return builderResult.hasZ
       }
  }
  var z:Double {
       get {
            return builderResult.z
       }
       set (value) {
           builderResult.hasZ = true
           builderResult.z = value
       }
  }
  func setZ(value:Double)-> HeadingBuilder {
    self.z = value
    return self
  }
  internal func clearZ() -> HeadingBuilder{
       builderResult.hasZ = false
       builderResult.z = Double(0)
       return self
  }
  override internal var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  internal override func clear() -> HeadingBuilder {
    builderResult = Heading()
    return self
  }
  internal override func clone() -> HeadingBuilder {
    return Heading.builderWithPrototype(builderResult)
  }
  internal override func build() -> Heading {
       checkInitialized()
       return buildPartial()
  }
  internal func buildPartial() -> Heading {
    var returnMe:Heading = builderResult
    return returnMe
  }
  internal func mergeFrom(other:Heading) -> HeadingBuilder {
    if (other == Heading()) {
     return self
    }
    if (other.hasTimestamp) {
        mergeTimestamp(other.timestamp)
    }
    if other.hasMagneticHeading {
         magneticHeading = other.magneticHeading
    }
    if other.hasHeadingAccuracy {
         headingAccuracy = other.headingAccuracy
    }
    if other.hasX {
         x = other.x
    }
    if other.hasY {
         y = other.y
    }
    if other.hasZ {
         z = other.z
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream) ->HeadingBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> HeadingBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:TimestampAndAudioTimeBuilder = TimestampAndAudioTime.builder()
        if hasTimestamp {
          subBuilder.mergeFrom(timestamp)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        timestamp = subBuilder.buildPartial()

      case 17 :
        magneticHeading = input.readDouble()

      case 25 :
        headingAccuracy = input.readDouble()

      case 33 :
        x = input.readDouble()

      case 41 :
        y = input.readDouble()

      case 49 :
        z = input.readDouble()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}


// @@protoc_insertion_point(global_scope)
